# 内建集合类型1-数组

在 Swift 中最常用的集合类型非数组莫属。数组是一个容器，它以有序的方式存储相同类型的元素，并且允许随机访问每个元素。

## 数组和可变性

和标准库中所有集合类型一样，数组Array是具有值语义的。当你把一个已经存在的数组赋值给另一个变量时，这个数组的内容会被复制。对比一下很多其他语言 (比如 JavaScript，Java 和使用 Foundation 框架中的 NSArray 的 Objective-C) 中对可变特性上处理的方法。这些语言中的数组使用引用语义：通过一个变量对数组的内容进行变更，会隐式地改变其他所有引用了这个数组的变量，因为他们全都指向了同一个存储。

Swift标准库中的所有集合类型都使用了“写时复制”这一技术，它能够保证只在必要的时候对数据进行复制。在我们的例子中，直到 y.append 被调用的之前，x 和 y 都将共享内部的存储。


## 数组索引

Swift 也有很多无需计算索引就能操作数组的方法：
1. 想要迭代数组？ for x in array
2. 想要迭代除了第一个元素以外的数组其余部分？ for x in array.dropFirst()
3. 想要迭代除了最后 5 个元素以外的数组？ for x in array.dropLast(5)
4. 想要列举数组中的元素和对应的下标？ for (num, element) in collection.enumerated()
5. 想要寻找一个指定元素的位置？ if let idx = array.index { someMatchingLogic($0) }  

first 和 last 属性返回一个可选值，当数组为空时，它们返回 nil。first 相当于 isEmpty ? nil : self[0]。 
类似地，如果数组为空时调用 removeLast，那么将会导致崩溃；然而 popLast 在数组不为空时删除最后一个元素并返回它，在数组为空时，它将不执行任何操作，直接返回 nil。


## 数组变形

你就会发现 map 就像是一个信号，一旦你看到它，就会知道即将有一个函数被作用在数组的每个元素上，并返回另一个数组，它将包含所有被转换后的结果。

1. map 和 flatMap — 对元素进行变换。
2. filter — 只包含特定的元素。
3. allSatisfy — 针对一个条件测试所有元素。
4. reduce — 将元素聚合成一个值。
5. forEach — 访问每个元素。
5. sort(by:), sorted(by:), lexicographicallyPrecedes(_:by:), 和 partition(by:) — 重排元素。
6. firstIndex(where:), lastIndex(where:), first(where:), last(where:), 和 contains(where:) — 一个元素是否存在？
7. min(by:) 和 max(by:) — 找到所有元素中的最小或最大值。
8. elementsEqual(_:by:) 和 starts(with:by:) — 将元素与另一个数组进行比较。
9. split(whereSeparator:) — 把所有元素分成多个数组。
10. prefix(while:) — 从头取元素直到条件不成立。
11. drop(while:) — 当条件为真时，丢弃元素；一旦不为真，返回其余的元素 (和 prefix 类似，不过返回相反的集合)。
12. removeAll(where:) — 删除所有符合条件的元素。

flatMap 的函数签名看起来和 map 基本一致，只是它的变换函数返回的是一个数组。在实现中，它使用 append(contentsOf:) 代替了 append(_:)，这样返回的数组是展平的了。  
compactMap和map的区别是过滤nil  swfit4.1 区分了compactMap和flatMap 是因为原来的flatMap违背单一职责原则，

for 循环和 forEach 有些细微的不同，值得我们注意。比如，当一个 for 循环中有 return 语句时，将它重写为 forEach 会造成代码行为上的极大区别，return 语句并不会终止循环，它做的仅仅是从闭包中返回，因此在 forEach 的实现中会开始下一个循环的迭代。

reduce 实现map和filter
```
extension Array {
  func map2<T>(_ transform: (Element) -> T) -> [T] {
    return reduce([]) {
      $0 + [transform($1)]
    }
  }

func filter2(_ isIncluded: (Element) -> Bool) -> [Element] {
  return reduce([]) {
      isIncluded($1) ? $0 + [$1] : $0
    }
  }

}
```



