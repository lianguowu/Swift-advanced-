# 属性1-变更观察者和延迟存储属性

Swift 中的属性有两种变体：存储属性和计算属性。存储属性可以存储实际的值，而计算属性则和函数更相似：它们不提供存储，而只提供一种对值的获取和 (可选的) 设置方法。从这方面考虑，你可以把计算属性想象成一种拥有不同语法的方法。

你可以认为属性就是定义在某个类型上的变量。我们在本章中提到的大部分内容，也适用于本地和全局变量。变量可以被存储或者计算，它们支持变更观察，也可以使用属性包装器。我们认为属性是变量的一种“特殊形式”，而不是反过来。

有两个重要的特性是在属性的基础上构建的：键路径 (key path) 和属性包装 (property wrapper)。


## 变更观察者

我们也可以为属性和变量实现 willSet 和 didSet 方法，每次当一个属性被设置时 (就算它的值没有发生变化)，这两个方法都会被调用。它们会分别在设置前和设置后被立即调用。

属性观察者必须在声明一个属性的时候就被定义，你无法在扩展里进行追加。所以，这不是一个提供给类型用户的工具，它是专门提供给类型的设计者的。

```
//你可以在子类中重写一个属性，来添加观察者。下面就是一个例子：
class Robot {
	enum State {
		case stopped, movingForward, turningRight, turningLeft
	}
	var state = State.stopped
}

class ObservableRobot: Robot {
	override var state: State {
		willSet {
			print("Transitioning from \(state) to \(newValue)")
		}
	}
}

var robot = ObservableRobot()
robot.state = .movingForward // Transitioning from stopped to movingForward”
```

使用上的差异被反应在这些特性的实现中。KVO 使用 Objective-C 的运行时特性，动态地在类的 setter 中添加观察者，这在现在的 Swift 中，特别是对值类型来说，是无法实现的。Swift 的属性观察是一个纯粹的编译时特性。

## 延迟存储属性 lazy property

延迟初始化一个值在 Swift 中是一种常见的模式，为了定义一个延迟初始化的属性，Swift 提供了一个专用的关键字 lazy。关键字来定义一个延迟属性 (lazy property)。要注意的是，延迟属性只能用 var 定义，因为在初始化方法完成后，它的初始值可能仍旧是未设置的。

和计算属性不同，存储属性和需要存储的延迟属性不能被定义在扩展中。同样地，和计算属性不一样，存储属性和延迟存储属性不会在这些属性每次被访问时去重新计算。

访问一个延迟属性是 mutating 操作，因为这个属性的初始值会在第一次访问时被设置。当结构体包含一个延迟属性时，这个结构体的所有者如果想要访问该延迟属性的话，也需要将结构体声明为可变量，因为访问这个属性的同时，也会潜在地对这个属性的容器进行改变。所以在结构体中使用延迟属性通常不是一个好主意”

另外需要注意，lazy 关键字不会进行任何线程同步。如果在一个延迟属性完成计算之前，多个线程同时尝试访问它的话，计算有可能进行多次，计算过程中的各种副作用也会发生多次。
