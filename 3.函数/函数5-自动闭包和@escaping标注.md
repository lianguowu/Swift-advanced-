# 函数5-自动闭包和@escaping标注

## 自动闭包

我们都对“逻辑与”，也就是 && 操作符如何对其参数求值很熟悉了：它会先对左边的操作数求值，如果左边的求值为 false 时，则直接返回。只有当左侧值为 true 时，右边的操作数才会被求值。这是因为，一旦左边的结果是 false 的话，整个表达式就不可能是 true 了。这种行为又被叫做短路求值。
```
if let first = evens.first, first > 10 {
    // 执行操作
}
//这是另一种形式的短路求值：第二个条件只有在第一个条件成功后，才会进行判断。
```
自定义模拟短路求值
```
func and(_ l: Bool, _ r: () -> Bool) -> Bool {
    guard l else { return false }
    return r()
}

//传入参数为函数
if and(!evens.isEmpty, { evens[0] > 10 }) {
    // 执行操作
}
```

在 Swift 中有一个很好的特性，能让代码更漂亮。我们可以使用 @autoclosure 标注来告诉编译器它应该将一个特定的参数用闭包表达式包装起来。通过这种方式构建的 and 的定义和上面几乎一样，除了在 r 参数前加上了 @autoclosure 标注
```
func and(_ l: Bool, _ r: @autoclosure () -> Bool) -> Bool {
    guard l else { return false }
    return r()
}

//传入参数为函数
if and(!evens.isEmpty, evens[0] > 10) {
    // 执行操作
}
```
不过请谨慎使用自动闭包特性。它们的行为与一般的期望有冲突 - 比如，要是某个表达式被自动闭包包装的话，它有可能不被执行，而导致其中的某些副作用没有生效。引用 Apple 的 Swift 书中的一段:过度使用自动闭包可能会让你的代码难以理解。使用时的上下文和函数名应该清晰地指出实际求值会被推迟。

## @escaping标注

一个被保存在某个地方 (比如一个属性中) 等待稍后再调用的闭包就叫做逃逸闭包。相对的，永远不会离开一个函数的局部作用域的闭包就是非逃逸闭包。对于逃逸闭包，编译器强制我们在闭包表达式中显式地使用 self，因为无意中对于 self 的强引用，是发生引用循环的最常见原因之一。当一个函数返回的时候，非逃逸闭包会自动销毁，所以它不会创建一个固定的引用循环.

闭包参数默认是非逃逸的。如果你想要保存一个闭包稍后再用，你需要将闭包参数标记为 @escaping。编译器将会对此进行验证，如果你没有将闭包标记为 @escaping，编译器将不允许你保存这个闭包 (或者比如将它返回给调用者)。


Swift 提供了一个 withoutActuallyEscaping 函数来作为一种“安全出口”。这个函数允许你对一个接受逃逸闭包的函数，传入一个非逃逸的闭包。
注意，使用 withoutActuallyEscaping 后，你就进入了 Swift 中不安全的领域。让闭包的复制从 withoutActuallyEscaping 调用的结果中逃逸的话，会造成不确定的行为



