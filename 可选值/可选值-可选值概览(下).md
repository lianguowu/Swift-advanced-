# 可选值-可选值概览(下)

## 可选链

在 Objective-C 中，对 nil 发消息什么都不会发生。Swift 里，我们可以通过“可选链 (optional chaining)”来达到同样的效果：
` delegate?.callback() `
但和 Objective-C 不同的是，Swift 编译器会强制要求你声明消息的接受者可能为nil。这里的问号对代码的读者来说是一个清晰地信号，表示方法可能会不被调用。  
当你通过调用可选链得到一个返回值时，这个返回值本身也会是可选值.
`let lower = str?.uppercased().lowercased() // Optional("never say never") `

这看起来有点出乎意料。我们不是刚刚才说过可选链调用的结果是一个可选值么？所以为什么在 uppercased() 后面不需要加上问号呢？这是因为可选链是一个“展平”操作。str?.uppercased() 返回了一个可选值，如果你再对它调用 ?.lowercased() 的话，逻辑上来说你将得到一个可选值的可选值。不过其实你想要得到的是一个普通的可选值，所以我们在写链上第二个调用时不需要包含可选的问号，因为可选的特性已经在之前就被捕获了。

另一方面，如果 uppercased 方法本身也返回一个可选值的话，你就需要在它后面加上 ? 来表示你正在链接这个可选值。比如，让我们对 Int 类型进行扩展，添加一个计算属性 half，这个属性将把整数值除以二并返回结果。但是如果数字不够大的话，比如当数字小于 2 时，函数将返回 nil：
```
extension Int {
	var half: Int? {
		guard self < -1 || self > 1 else { return nil }
		return self / 2
	}
}
```

因为调用 half 返回一个可选结果，因此当我们重复调用它时，需要一直添加问号。因为函数的每一步都有可能返回 nil  
`20.half?.half?.half // Optional(2) `
编译器非常聪明，它能为我们展平结果类型。上面的表达式的类型正是我们期待的 Int?，而不是 Int???。后一种类型可以给我们更多的信息，比如说可选链是在哪个部分解包失败的，但是这也会让结果非常难以处理，从而让可选链一开始时给我们带来的便利性损失殆尽.
```
let dictOfFunctions: [String: (Int, Int) -> Int] = [
	"add": (+),
	"subtract": (-)
]
dictOfFunctions["add"]?(1, 1) // Optional(2)
```

设想一个类在某个事件发生时，要通过调用存储在其中的回调函数来通知其所有者，上面的特性就会非常有用。比如有一个 TextField 类：
```
class TextField {
	private(set) var text = ""
	var didChange: ((String) -> ())?
	// 被框架调用的事件处理方法。
	func textDidChange(newText: String) {
		text = newText
		// 如果不是 nil 的话，触发回调。
		didChange?(text)
	}
}
```

didChange 属性存储了一个回调函数，每当用户编辑文本时，这个函数都会被调用。因为文本框的所有者并不一定需要注册这个回调，所以该属性是可选值，它的初始值为 nil 。当这个回调被调用的时候 (在上面的 textDidChange 方法中)，可选链的写法就非常简洁了。

你还可以通过可选链来进行赋值。假设你有一个可选值变量，如果它不是 nil 的话，你想要更新它的一个属性：
```
struct Person {
	var name: String
	var age: Int
}

var optionalLisa: Person? = Person(name: "Lisa Simpson", age: 8)
// 如果不是 nil，则增加 age
if optionalLisa != nil {
	optionalLisa!.age += 1
}
```
这种写法非常繁琐，也很丑陋。特别注意，在这种情况下你不能使用可选绑定。因为 Person 是一个结构体，所以它是一个值类型，绑定后的值只是原来值的局部作用域的复制，对这个复制进行变更，并不会影响原来的值  
其实，你可以使用可选值链来进行赋值，如果它不是 nil 的话，赋值操作将会成功：
`optionalLisa?.age += 1`


## nil合并运算符

在解包可选值的同时，为 nil 的情况设置一个默认值。而这正是 nil 合并运算符的功能
```
let stringteger = "1"
let number = Int(stringteger) ?? 0

let array = [1,2,3]
array.first ?? 0 // 1
```
假设你要做的不是对空数组判定，而是要检查一个索引值是否在数组边界内：
`array.count > 5 ? array[5] : 0 // 0`
不像 first 和 last，通过索引值从数组中获取元素不会返回 Optional。不过我们可以对 Array 进行扩展来包含这个功能：
```
extension Array {
	subscript(guarded idx: Int) -> Element? {
		guard (startIndex..<endIndex).contains(idx) else {
			return nil
	}
		return self[idx]
	}
}

array[guarded: 5] ?? 0 // 0 
```
合并操作也能够进行链接 — 如果你有多个可选值，并且想要选择第一个非 nil 的值，你可以将它们按顺序合并：
```
let i: Int? = nil
let j: Int? = nil
let k: Int? = 42
i ?? j ?? k ?? 0 // 42
```
正因为如此，所以如果你要处理的是双重嵌套的可选值，并且想使用 ?? 操作符的话，需要特别小心区分 a ?? b ?? c 和 (a ?? b) ?? c。前者是合并操作的链接，而后者是先解包括号内的内容，然后再处理外层
```
let s1: String?? = nil // nil
(s1 ?? "inner") ?? "outer" // inner
let s2: String?? = .some(nil) // Optional(nil)
(s2 ?? "inner") ?? "outer" // outer
```
如果你将 ?? 操作符看作是和 “or” 语句类似的话，那么可以把多个并列的 if let 语句视作 “and” 语句  
和 || 操作符一样，?? 操作符使用短路求值 (short circuiting)。当我们用 l ?? r 时，只有当 l 为 nil 时，r 的部分才会被求值。这是因为在操作符的函数声明中，对第二个参数使用了 @autoclosure。我们会在函数中详细讨论自动闭包 (autoclosure) 的工作原理.

##在字符串插值中使用可选值

可能你已经注意到了，当你尝试打印一个可选值或者将一个可选值用在字符串插值表达式中时，编译器会给出警告：
```
let bodyTemperature: Double? = 37.0
let bloodGlucose: Double? = nil
print(bodyTemperature) // Optional(37.0)
// 警告：表达式被隐式强制从 'Double?' 转换为 Any
print("Blood glucose level: \(bloodGlucose)") // Blood glucose level: nil
// 警告：字符串插值将使用调试时的可选值描述，
// 请确认这确实是你想要做的。
```
编译器为我们提供了几种修正这个警告的方式：显式地用 as Any 进行转换，使用 ! 对值进行强制解包 (如果你能确定该值不为 nil 时)，使用 String(describing: …) 对它进行包装，或者用 nil 合并运算符提供一个默认值。  
最后一种做法通常是比较快捷和优雅的方式，但是它有一点不足：在 ?? 表达式两侧的类型必须匹配，也就是说，你为一个 Double? 类型提供的默认值必须是 Double。因为我们最终的目标是将表达式转换为一个字符串，所以如果我们能够一开始就提供一个字符串作为默认值的话，就会特别方便。 

Swift 的 ?? 运算符不支持这种类型不匹配的操作，确实，它无法决定当表达式两侧不共享同样的基础类型时，到底应该使用哪一个类型。不过，只是为了在字符串插值中使用可选值这一特殊目的的话，添加一个我们自己的运算符也很简单。让我们把它叫做 ???：
```
infix operator ???: NilCoalescingPrecedence
public func ???<T>(optional: T?, defaultValue: @autoclosure () -> String)
-> String {
	switch optional {
	case let value?: return String(describing: value)
	case nil: return defaultValue()
	}
}
```
这个函数接受左侧的可选值 T? 和右侧的字符串。如果可选值不是 nil，我们将它解包，然后返回它的字符串描述。否则，我们将传入的默认字符串返回。@autoclosure 标注确保了只有当需要的时候，我们才会对第二个表达式进行求值


## 可选值map

可选值不为 nil 的时候才进行转换的模式十分常见。因此，可选值提供了一个 map 方法专门处理这个问题。它接受一个转换可选值内容的函数作为参数。把刚才转换字符数组的功能用 map 来实现，就是这样的
```
let firstChar = characters.first.map { String($0) } // Optional("a")
```
显然，这个 map 和数组以及其他序列里的 map 方法非常类似。但是与序列中操作一系列值所不同的是，可选值的 map 方法只会操作一个值，那就是该可选值中的那个可能存在的值。你可以把可选值当作一个包含零个或者一个值的集合，这样 map 要么在零个值的情况下不做处理，要么在有值的时候会对其进行转换.  
以下是在可选值上实现 map 的一种方式
```
extension Optional {
	func map<U>(transform: (Wrapped) -> U) -> U? {
	guard let value = self else { return nil }
		return transform(value)
	}
}
```
当你想要的就是一个可选值结果时，Optional.map 就非常有用。假设你要为数组实现一个变种的 reduce 方法，这个方法不接受初始值，而是直接使用数组中的首个元素作为初始值 (在一些语言中，这个函数可能被叫做 reduce1，但是 Swift 里我们有重载，所以也将它叫做 reduce 就行了)。因为数组可能会是空的，这种情况下没有初始值，结果只能是可选值。你可能会这样来实现它
```
extension Array {
	func reduce(_ nextPartialResult: (Element, Element) -> Element) -> Element? {
		// 如果数组为空，first 将是 nil
		guard let fst = first else { return nil }
		return dropFirst().reduce(fst, nextPartialResult)
	}
}
```

因为可选值为 nil 时，可选值 map 也会返回 nil，所以我们可以不使用 guard，而就用一个 return 来重写我们的这个 reduce
```
extension Array {
	func reduce_alt(_ nextPartialResult: (Element, Element) -> Element) -> Element? {
		return first.map {
			dropFirst().reduce($0, nextPartialResult)
		}
	}
}
```

## 可选值flatMap



















