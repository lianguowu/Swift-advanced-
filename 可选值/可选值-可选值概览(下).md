# 可选值-可选值概览(下)

## nil合并运算符

在解包可选值的同时，为 nil 的情况设置一个默认值。而这正是 nil 合并运算符的功能
```
let stringteger = "1"
let number = Int(stringteger) ?? 0

let array = [1,2,3]
array.first ?? 0 // 1
```
假设你要做的不是对空数组判定，而是要检查一个索引值是否在数组边界内：
`array.count > 5 ? array[5] : 0 // 0`
不像 first 和 last，通过索引值从数组中获取元素不会返回 Optional。不过我们可以对 Array 进行扩展来包含这个功能：
```
extension Array {
	subscript(guarded idx: Int) -> Element? {
		guard (startIndex..<endIndex).contains(idx) else {
			return nil
	}
		return self[idx]
	}
}

array[guarded: 5] ?? 0 // 0 
```
合并操作也能够进行链接 — 如果你有多个可选值，并且想要选择第一个非 nil 的值，你可以将它们按顺序合并：
```
let i: Int? = nil
let j: Int? = nil
let k: Int? = 42
i ?? j ?? k ?? 0 // 42
```
正因为如此，所以如果你要处理的是双重嵌套的可选值，并且想使用 ?? 操作符的话，需要特别小心区分 a ?? b ?? c 和 (a ?? b) ?? c。前者是合并操作的链接，而后者是先解包括号内的内容，然后再处理外层
```
let s1: String?? = nil // nil
(s1 ?? "inner") ?? "outer" // inner
let s2: String?? = .some(nil) // Optional(nil)
(s2 ?? "inner") ?? "outer" // outer
```
如果你将 ?? 操作符看作是和 “or” 语句类似的话，那么可以把多个并列的 if let 语句视作 “and” 语句  
和 || 操作符一样，?? 操作符使用短路求值 (short circuiting)。当我们用 l ?? r 时，只有当 l 为 nil 时，r 的部分才会被求值。这是因为在操作符的函数声明中，对第二个参数使用了 @autoclosure。我们会在函数中详细讨论自动闭包 (autoclosure) 的工作原理.

## 在字符串插值中使用可选值

可能你已经注意到了，当你尝试打印一个可选值或者将一个可选值用在字符串插值表达式中时，编译器会给出警告：
```
let bodyTemperature: Double? = 37.0
let bloodGlucose: Double? = nil
print(bodyTemperature) // Optional(37.0)
// 警告：表达式被隐式强制从 'Double?' 转换为 Any
print("Blood glucose level: \(bloodGlucose)") // Blood glucose level: nil
// 警告：字符串插值将使用调试时的可选值描述，
// 请确认这确实是你想要做的。
```
编译器为我们提供了几种修正这个警告的方式：显式地用 as Any 进行转换，使用 ! 对值进行强制解包 (如果你能确定该值不为 nil 时)，使用 String(describing: …) 对它进行包装，或者用 nil 合并运算符提供一个默认值。  
最后一种做法通常是比较快捷和优雅的方式，但是它有一点不足：在 ?? 表达式两侧的类型必须匹配，也就是说，你为一个 Double? 类型提供的默认值必须是 Double。因为我们最终的目标是将表达式转换为一个字符串，所以如果我们能够一开始就提供一个字符串作为默认值的话，就会特别方便。 

Swift 的 ?? 运算符不支持这种类型不匹配的操作，确实，它无法决定当表达式两侧不共享同样的基础类型时，到底应该使用哪一个类型。不过，只是为了在字符串插值中使用可选值这一特殊目的的话，添加一个我们自己的运算符也很简单。让我们把它叫做 ???：
```
infix operator ???: NilCoalescingPrecedence
public func ???<T>(optional: T?, defaultValue: @autoclosure () -> String)
-> String {
	switch optional {
	case let value?: return String(describing: value)
	case nil: return defaultValue()
	}
}
```
这个函数接受左侧的可选值 T? 和右侧的字符串。如果可选值不是 nil，我们将它解包，然后返回它的字符串描述。否则，我们将传入的默认字符串返回。@autoclosure 标注确保了只有当需要的时候，我们才会对第二个表达式进行求值


## 可选值map

可选值不为 nil 的时候才进行转换的模式十分常见。因此，可选值提供了一个 map 方法专门处理这个问题。它接受一个转换可选值内容的函数作为参数。把刚才转换字符数组的功能用 map 来实现，就是这样的
```
let firstChar = characters.first.map { String($0) } // Optional("a")
```
显然，这个 map 和数组以及其他序列里的 map 方法非常类似。但是与序列中操作一系列值所不同的是，可选值的 map 方法只会操作一个值，那就是该可选值中的那个可能存在的值。你可以把可选值当作一个包含零个或者一个值的集合，这样 map 要么在零个值的情况下不做处理，要么在有值的时候会对其进行转换.  
以下是在可选值上实现 map 的一种方式
```
extension Optional {
	func map<U>(transform: (Wrapped) -> U) -> U? {
	guard let value = self else { return nil }
		return transform(value)
	}
}
```
当你想要的就是一个可选值结果时，Optional.map 就非常有用。假设你要为数组实现一个变种的 reduce 方法，这个方法不接受初始值，而是直接使用数组中的首个元素作为初始值 (在一些语言中，这个函数可能被叫做 reduce1，但是 Swift 里我们有重载，所以也将它叫做 reduce 就行了)。因为数组可能会是空的，这种情况下没有初始值，结果只能是可选值。你可能会这样来实现它
```
extension Array {
	func reduce(_ nextPartialResult: (Element, Element) -> Element) -> Element? {
		// 如果数组为空，first 将是 nil
		guard let fst = first else { return nil }
		return dropFirst().reduce(fst, nextPartialResult)
	}
}
```

因为可选值为 nil 时，可选值 map 也会返回 nil，所以我们可以不使用 guard，而就用一个 return 来重写我们的这个 reduce
```
extension Array {
	func reduce_alt(_ nextPartialResult: (Element, Element) -> Element) -> Element? {
		return first.map {
			dropFirst().reduce($0, nextPartialResult)
		}
	}
}
```

## 可选值flatMap



















