# 强制解包的时机

上面提到的例子都用了很干净的方式来解包可选值，那什么时候你应该用感叹号 (!) 这个强制解包运算符呢？。我们提出了下面这个规则，它概括了大多数的场景：当你能确定你的某个值不可能是 nil 时可以使用叹号，另外在调试阶段，你会希望如果它意外是 nil 的话，程序应当直接挂掉。

举个例子，看看之前 compactMap 的实现
```
extension Sequence {
	func compactMap<B>(_ transform: (Element) -> B?) -> [B] {
		return lazy.map(transform).filter { $0 != nil }.map { $0! }
	}
}
```
不过这些情况还是很罕见的。如果你完全掌握了本章中提到的解包的知识，一般应该可以找到比强制解包更好的方法。每当你发现需要使用 ! 时，可以回头看看是不是真的别无他法了。

尽管如此，有时还是会造化弄人，你有一个可选值，并且确实知道它不可能是 nil。在这种情况下，当你碰到一个 nil 值的时候，你肯定会选择让程序挂掉而不是让它继续运行，因为这意味在你的逻辑中有一个非常严重的 bug。此时，终止程序而不是让它继续运行会是更好的抉择，这里 ! 这一个符号就实现了“解包”和“报错”两种功能的结合。相比于使用 nil 可选链或者合并运算符来在背后清除这种理论上不可能存在的情况的方法，直接强制解包的处理方式通常要好一些。


## 改进强制解包的错误信息

就算你要对一个可选值进行强制解包，除了使用 ! 操作符以外，你还有其他的选择。当程序发生错误时，你从输出的 log 中无法通过描述知道原因是什么。

其实，你可能会留一个注释来提醒为什么这里要使用强制解包。那为什么不把这个注释直接作为错误信息呢？这里我们加了一个 !! 操作符，它将强制解包和一个更具有描述性质的错误信息结合在一起，当程序意外退出时，这个信息也会被打印出来：
```
infix operator !!
func !! <T>(wrapped: T?, failureText: @autoclosure () -> String) -> T {
	if let x = wrapped { return x }
	fatalError(failureText())
}
```
现在你可以写出更能描述问题的错误信息了，它还包括了你期望的被解包的值：
```
let s = "foo"
let i = Int(s) !! "Expecting integer, got \"\(s)\"
```

## 在调试版本中进行断言
调试版本或者测试版本中进行断言，让程序崩溃，但是在最终产品中，你可能会把它替换成像是零或者空数组这样的默认值
```

```