# 枚举3-switch语句的完备性

多数情况下，switch 只是对于带有多个 else if case 条件的 if case 语句的一种更方便的语法而已。除了语法差异之外，它们之间还有一个重要的区别：一个 switch 语句必须是完备的，也就是说，它的分支必须覆盖所有可能的输入值。编译器也会强制执行这个完备性。

然而当 switch 枚举时，是不会发生漏判 (False negative) 的。对于以下的类型，完备性检查是完全可以信赖的：

1. 布尔值
2. 枚举，只要任何关联值可以被检测出是完备的，或者你用某个模式来匹配任意的关联值 (例如，通配符或值绑定)
3. 元组，只要它的成员类型可以被检测出是完备的


## 不可能产生非法的状态

有太多正面的理由来解释为什么要使用像是 Swift 这种静态类型语言。性能是其中之一：编译器对于程序中变量的类型知道的越多，通常就越能产生更快的代码。
另一个同样重要的理由是，类型系统可以指导开发人员应该如何使用 API。

以下是我们设计自定义类型时，为了从编译器获得最大程度帮助的建议：使用类型使其无法表示非法状态。


## 使用枚举来实现Model状态

如何在我们的程序中实现状态，并且不让状态出现非法情况，是程序设计的另一个主要方面。在一个给定的时间点上，程序的状态包括所有变量的内容加上 (隐式地) 其当前的执行状态，即哪些线程正在运行以及它们正在执行哪条指令。

例如 设计一个聊天的程序
```
struct StateStruct {
	var isLoading: Bool
	var messages: [Message]?
	var error: Error?
}
// 设置初始状态。
var structState = StateStruct(isLoading: true, messages: nil, error: nil)
```
由于结构体是一个乘积类型，因为我们的程序只需要处理这八种状态中的三种：加载，显示一个消息列表或显示一个错误。如果我们正确实现了程序的话，另外五个状态都应该是不会发生的无效组合，但我们无法指望编译器能在我们创建了一个无效的状态时给出警报。

用枚举去实现
```
enum StateEnum {
	case loading
	case loaded([Message])
	case failed(Error)
}
// 设置初始状态
var enumState = StateEnum.loading
```

每次需要访问一些依赖状态的数据 (例如，消息数组) 时，我们现在都 switch 枚举来提取关联值。因为 switch 语法是非常严格的，所以有时会让人觉得不方便。但这是一个重要的安全性方面的特性，因为它强迫我们总是处理每个可能的状态 - 至少会检查我们是否在 switch 语句中使用了 default 分支。

总而言之，枚举是实现状态的绝佳选择。它可以在很大程度上防止无效状态，并将子系统 (或者甚至是整个程序) 的整个状态都放在一个变量中，从而使状态转换更不容易出错。此外，switch 语句的完备性允许编译器能在你添加了一个新的状态，或改变了现有状态的关联值时，指出需要更新的代码路径.


## 在枚举和结构体之间做选择

本章前面一点的部分，我们讨论了枚举和结构体之间如何具有非常不同的特性：一个枚举值精确地表示所有成员中的一个 (加上它的关联值)，但一个结构体的值表示的是它所有属性的值。

枚举和结构体都具有其独特的特性

1. 如果我们让结构体的初始化方法的访问级别为 internal 或 public 的话，则可以在其他文件或者甚至其他模块中通过添加静态方法或属性来扩展这个结构体，从而添加新的分析事件到 API 中。枚举的版本是无法实现这一点的：你不能在其他地方添加新的成员到枚举中。
2. 枚举可以更精确地实现数据类型；它只能表示预定义成员中的一个，但结构体因为这两个属性而可能表示无限多的值。如果你想对事件做额外的处理 (例如，合并事件序列)，则枚举的精确性和安全性会派上用场。
3. 结构体可以有私有“成员” (也就是说，对所有使用者都不可见的静态方法或静态属性)，而枚举中成员的可见性始终和枚举本身保持一致。
4. 你可以对枚举使用 switch 语句，并利用语句的完备性来确保不会错过任何一个事件的类型。但由于这种严格性，所以向枚举添加一个新的事件类型就可能会破坏使用这个 API 用户的源代码，但你可以为新的事件类型往结构体中添加静态方法，而不用担心会影响其他代码。


## 枚举和协议之间的相似之处

我们提到过枚举不是唯一可以表示“之一”关系的结构；协议也可用于此目的。

基于枚举的是现实按照方法来分组的。
基于协议是按照成员进行分组的。

扩展性方面的差异：
1. 枚举的版本中我之后可以轻松地添加新的渲染方法，我们无法再枚举中添加新的形状
2. 协议的版本中我们可以轻松地添加形状，新建一个结构体遵循协议，但是无法现价新的渲染方法（扩展方法通常不适合向协议添加新功能）


## 使用枚举实现递归数据结构

```
//实现一个XML的小子集
enum Node: Hashable {
	case text(String)

	indirect case element(
		name: String, 
		attributes: [String: String] = [:],
		children: Node = .fragment([]))

	case fragment([Node])
}
```
请注意 indirect 关键字，这是使代码能编译通过所必需的。indirect 告诉编译器把 element 成员表示为一个引用，从而使递归起作用。如果 element 没有成为一个引用，那么这个枚举就将会拥有无限大尺寸。

## indirect

为了理解为什么我们要将递归的 Node 枚举声明为 indirect，枚举是值类型这件事。值类型是不能包含自身的，因为如果允许这样的话，在计算类型大小的时候，就会创建一个无限递归。编译器必须能够为每种类型确定一个固定且有限的尺寸。将需要递归的成员作为一个引用是可以解决这个问题的，因为引用类型在其中增加了一个间接层；并且编译器知道任何引用的存储大小 (在一个 64 位的系统上) 总是为 8 个字节。

注意，虽然 fragment 中也递归使用了 Node，但我们并没有在它前写 indirect。这是因为这个关联值是一个数组，而数组这个结构体具有固定尺寸 (数组中元素使用的实际内存被存储在一个缓冲区中)。

indirect语法只能用在枚举上，只会作用在关联值上。

