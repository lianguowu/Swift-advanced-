# 枚举2-模式匹配

检查一个枚举值最常用方法就是使用 switch 语句，它允许我们在单个语句中，将值与多个候选值 (candidates) 进行比较。使用 switch 语句还有一个额外的好处，就是它有一个方便的语法，可以一口气做完值与成员的比较和提取关联值这两件事。这个机制被称为模式匹配。模式匹配不是 switch 所独有的，但却是最明显的用例。
模式匹配是有用的，因为它让我们可以通过结构而不是内容，来解构一个数据结构。将纯匹配与值绑定相结合的能力使其特别的强大。

swift支持的模式类型

1. 通配符模式 - 符号为下划线：_ .它匹配任意值并忽略这个值。当匹配到关联值的一部分，并想忽略另一部分的时候，就可以使用它了。在上面的代码中，我们已经在 .success((42, _ )) 模式中看到了用通配符的例子。在 switch 语句中，case _ 是等同于 default 关键字的：两者都匹配任意值，并且把它们作为最后一个分支才是合理的。

2. 元组模式 - 使用一个用逗号分割的子模式 (subpattern) 列表来匹配元组。例如，(let x, 0, _ ) 匹配的是一个含有三个元素的元组，其中第二个元素为 0，然后把第一个元素与 x 做绑定。元组模式本身只匹配元组的结构，也就是说，只匹配在括号内用逗号分割的元素数量

3. 枚举成员模式 - 匹配指定的枚举成员。它可以包含子模式来处理关联值，像是等式检查 (.success(42)) 或值绑定 (.failure(let error)) 这种。为了忽略一个关联值，可以在子模式中使用下划线，或删除整个子模式来达到目的，例如，.success( _ ) 和 .success 就是等价的。

4. 值绑定模式 - 把一个匹配值的部分或全部，绑定到一个新的常量或变量上。语法是 let someIdentifier 或 var someIdentifier 这样。绑定变量的作用域就在其声明的那个 case 语句块中。

5. 可选值模式 - 通过使用我们所熟悉的问号语法，为匹配及解包可选值这两个操作，提供了一个语法糖。模式 let value? 等价于 .some(let value)，也就是说，它匹配一个不为 nil 的可选值，并把解包出来的值和一个常量绑定。

6. 类型转换模式 - 模式 is SomeType 匹配成功的条件是，一个值的运行时类型必须是 SomeType 或是其子类。模式 let value as SomeType 会执行同样的检查，并且另外还会将匹配的值转换为指定的类型，而 is 只会检查类型。

7. 表达式模式 - 通过把输入值和模式作为参数传递给定义在标准库中的模式匹配操作符 (~=) 来匹配表达式。对于实现 Equatable 协议的类型，~ = 的默认实现就是转发到 == 中，这也是在模式中简单的等式检查的工作方式。

## 在其他上下文中的模式匹配

虽然模式匹配是从枚举中提取关联值的唯一方式，但它不是专属于枚举或 switch 语句的。

在赋值时解构元组，例如，let (word, pi) = ("Hello", 3.1415) 或迭代时的 for (key, value) in dictionary { ... }。请注意在 for 循环的例子中，我们没有使用 let 来指明这是一个值绑定。因为在这种情况下，默认所有标识符都是值绑定。

if case 和 guard case 语句类似于只有单个分支的 switch 语句。尽管在许多情况下，我们为了利用编译器的完备性检查而更喜欢用 switch 语句，但因为这两个语句所需的行数要少于 switch，所以它们偶尔还是有用的。

for case 和 while case 循环的工作方式类似于 if case。它们允许你仅在模式匹配成功时才执行循环体。


## 使用枚举进行设计

那么让我们看一下在代码中，可以使用的一些充分利用了枚举各种特性的模式。我们将它们分为六个主要方面：

0. Switch 语句的完备性
1. 不可能产生非法的状态
2. 使用枚举来实现 Model 状态
3. 在枚举和结构体之间做选择
4. 枚举和协议之间的相似之处
5. 使用枚举实现递归数据结构”
