# 结构体和类1-值类型引用类型和可变性

结构体是值类型，类是引用类型。

## 值类型和引用类型

这种行为揭示了值类型的本质：赋值意味着按值拷贝。也就是说，每个值类型变量所持有的值都是独立的。具有这种行为特征的类型被称为具有值语义 (value semantics)。

值类型的特征就是变量和值之间的这种直接关系：在变量的背后，值 (也可以说是值类型的实例) 直接保存在变量指向的内存位置。这不但适用于像整数这样简单的值类型，同样也适用于更复杂的类型。

这就是引用类型的本质：变量不含有“事物”本身 (例如，UIView 或 URLSession 的实例)，而是持有一个对“事物”的引用。其他变量也可以含有对同一个实例的引用，并可以通过任意一个指向它的变量对其做修改。具有这些特性的类型被称为具有引用语义 (reference semantics)。一个引用类型变量含有一个指针，指向在内存中某个地方真正的实例。


## 可变性

但这里，对类和结构体的修改有一个非常重要的区别：对于结构体的修改永远都只是修改局部变量，也就是说，我们只修改了局部变量 scoreStruct 的值。而对于类实例的修改可能会产生全局性的影响：这个修改会影响其他那些，持有指向同一个实例的引用的对象。

```
var scoreClass = ScoreClass(home: 0, guest: 0)
var scoreStruct = ScoreStruct(home: 0, guest: 0)
scoreClass.home += 1
scoreStruct.guest += 1
// 等同于 scoreStruct = ScoreStruct(home: scoreStruct.home,guest: scoreStruct.guest + 1)


let scoreClass = ScoreClass(home: 0, guest: 0)
let scoreStruct = ScoreStruct(home: 0, guest: 0)
scoreClass.home += 1 // 可以工作
scoreStruct.guest += 1
// 错误：可变操作符的左侧是不可变类型”

```

要理解在属性和变量上用 let 和 var 的所有不同组合的关键是要记住两点：
1. 类型为类的变量的值，是一个指向实例的引用；而类型为结构体的变量的值，是结构体实例本身。
2. 修改一个结构体的属性，即使修改的是多层的嵌套属性，都等同于给变量赋值一个全新的结构体实例。

## 可变方法

在结构体上用 func 关键字定义的普通方法，是不能修改结构体的任何属性的。这是因为被隐式传入的 self 参数，默认是不可变的。我们必须明确地使用 mutating func 关键字来创建一个可变方法。
在可变方法中，我们可以认为 self 是一个用 var 声明的变量，所以也就可以修改那些在 self 中，用 var 声明的属性。

属性和下标的 setter 都是隐式的可变方法。在极少数的情况下，你会希望使用一个不可变的 setter 来实现计算属性，例如，你的结构体封装了一个全局资源，而相应属性的 setter 只是去修改这个全局状态。这个时候，你可以用 nonmutating set 来标注相应的 setter。编译器允许你在一个 let 常量上调用此类 setter。

## inout参数

属性和下标的 setter 都是隐式的可变方法。在极少数的情况下，你会希望使用一个不可变的 setter 来实现计算属性，例如，你的结构体封装了一个全局资源，而相应属性的 setter 只是去修改这个全局状态。这个时候，你可以用 nonmutating set 来标注相应的 setter。编译器允许你在一个 let 常量上调用此类 setter。

为了向 scoreGuest 函数传递 inout 参数，我们必须做两件事：首先，作为 inout 参数传递的变量必须是用 var 定义的；其次，当把这个变量传递给函数时，必须在变量名前加上 & 符号。站在调用者的角度，& 符号可以清楚的表明，这个函数会修改传入的变量的值。

虽然 & 符号可能会让你想起 C 和 Objective-c 中的取址操作符，或者是 C++ 中的引用传递操作符，但在 Swift 中，其作用是不一样的。就像对待普通的参数一样，Swift 还是会复制传入的 inout 参数，但当函数返回时，会用这些参数的值覆盖原来的值。也就是说，即使在函数中对一个 inout 参数做多次修改，但对调用者来说只会注意到一次修改的发生，也就是在用新的值覆盖原有值的时候。同理，即使函数完全没有对 inout 参数做任何的修改，调用者也还是会注意到一次修改 (willSet 和 didSet 这两个观察者方法都会被调用)。正如我们在函数一章中解释过的那样，编译器会在安全的时候，把复制操作优化掉，转而变成传递引用。

