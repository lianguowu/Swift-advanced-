# 结构体和类2-生命周期

在生命周期管理方面，结构体和类是非常不同的。相比类，结构体要简单得多，因为它们不会有多个所有者，它们的生命周期，是和含有结构体实例的变量的生命周期绑定的。当变量离开作用域时，其内存将被释放，结构体实例也会被销毁。

与此相反，一个类的实例可以被多个所有者引用，这就需要一种更精细的内存管理模型。Swift 使用自动引用计数 (ARC) 来追踪一个实例的引用计数。当引用计数降至 0 时 (例如所有包含引用的变量都离开了作用域，或被设置成了 nil)，Swift 运行时会调用对象的 deinit 方法并释放内存。因此，对那些在最终被释放时需要执行清理工作的共享对象，是可以用类来实现的。


## 循环引用

因为结构体是值类型，所以在结构体之间是不会产生循环引用的 (因为不存在对结构体的引用)。这即是优势又是限制：一方面我们可以少担心一件事，但同时也意味着无法用结构体实现循环数据结构 (cyclical data structure)。类的情况正好相反：因为一个实例可以有多个所有者，所以可以使用类来实现循环数据结构，但必须要小心，不要产生循环引用了。


## 弱引用

为了打破循环引用，我们需要使其中一个引用变为弱引用或 unowned 引用。把一个对象赋值给一个弱引用变量，并不会改变实例的引用计数。在 Swift 里，弱引用变量是归零 (zeroing) 的：一旦所指向的对象被销毁，变量会自动被设置成 nil。这也是为什么弱引用变量必须是可选值的原因。


## unowned 引用

但有时候，我们希望一个引用既是弱引用，但同时又不是一个可选值。例如，也许我们知道，view 永远都会拥有一个 window (所以这个属性不应该是可选值)，但又不希望 view 强引用 window。对于这种情况，可以使用 unowned 关键字。

对于 unowned 引用，我们的责任是，确保“被引用者”的生命周期比“引用者”要长。在这个例子中，我们必须确保 window 的生命周期比 view 长。如果 window 在 view 之前被销毁，并且之后再访问这个 unowned 变量的话，程序就会崩溃。

要注意的是，这里的崩溃与未定义行为是不同的。在对象中，Swift 运行时使用另外一个引用计数来追踪 unowned 引用。当对象没有任何强引用的时候，会释放所有资源 (例如，对其他对象的引用)。然而，只要对象还有 unowned 引用存在，其自身所占用的内存就不会被回收。这块内存会被标记为无效，有时也称作僵尸内存 (zombie memory)。被标记为僵尸内存之后，只要我们尝试访问这个 unowned 引用，就会发生一个运行时错误。


## 闭包和循环引用

在 Swift 中，类不是唯一的引用类型。我们在稍后并发一章中要提到的 actor，以及函数 (也包括闭包表达式和方法) 同样也是引用类型。如果一个闭包捕获了一个引用类型的变量，那么在闭包中会持有一个对这个变量的强引用。

我们可以使用一个捕获列表 (capture list)，并在捕获列表中弱引用 view，这样就能确保闭包不会强引用 view。在这个例子中，这是唯一正确的做法。

window?.onRotate = { [weak view] in
	print("We now also need to update the view: \(String(describing: view))")
}


## 在unowned引用和弱引用之间的选择

在自己设计的 API 中，如何在这两种引用中做选择呢？说到底，这个问题的答案取决于对象的生命周期。如果对象具有独立的生命周期 (也就是说，你不能保证哪一个对象存在的时间会比另一个长)，那么弱引用是唯一安全的选择。

另一方面，如果你可以保证，非强引用的对象与持有这个引用的对象的生命周期是一样的，甚至于更长的话，unowned 引用通常是更方便的。因为它的类型不需要是可选值，并可以被声明为 let，而弱引用则必须是用 var 声明的可选值。
