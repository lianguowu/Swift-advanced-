# 泛型3-泛型的工作方式

## 泛型和工作方式

举例泛型函数
```
func min<T: Comparable>(_ x: T, _ y: T) -> T {
	return y < x ? y : x
}
```

对于 min 函数，参数和返回值唯一的约束是所有三个值都必须拥有相同的类型 T，而且 T 必须满足 Comparable。
编译期间编译器都还不知道的类型。这意味着，编译器无法为这个函数生成代码，因为它缺少了三个必要的信息：

1. 类型 T 的值的大小 (包括参数和返回值)。
2. 如何复制和销毁类型 T 的值 (比如，它们是否需要引用计数)。
3. 需要调用的指定重载的 < 函数的地址。


Swift 通过向泛型代码引入一层间接层来解决这些问题：

1. 使用指针来传递大小未知的函数参数，返回值以及变量。

2. 对每个泛型类型参数 T，编译器会把 T 的类型元数据 (type metadata) 传递到函数中去。类型元数据记录包含了类型的**值目击表 (value witness table, VWT)**和其他一些东西。VWT 提供了对类型 T 的值的进行基本操作的函数，比如如何复制，移动，或者销毁一个值。对于一些像是 Int 这样简单值类型，它们可能是无操作或者内存复制，但对于引用类型来说，可能就会包含引用计数的逻辑。VWT 还对类型的内存布局 (大小和对齐) 进行了记录。

3. 对于 T 上的每个约束，编译器都会将一个协议目击表 (protocol witness table, PWT) 传递给函数。PWT 是一个记录有协议要求方法的虚拟表。它用来在运行时将函数调用动态地派发到合适的实现去。在我们的例子中，对于满足了 Comparable 的T，PWT 会提供正确的 < 函数。

PWT 提供了一种映射关系，来把泛型参数所实现的协议 (编译器在静态时就能通过约束得知) 和特定类型中实现了这个协议的函数 (这只有在运行时才知道) 联系起来。实际上，调用协议的方法的唯一途径，就只有通过 PWT。我们无法定义一个没有约束条件的 < T > 版本的 min 方法，如果没有满足 Comparable 这一条件，就算对应类确实实现了 < 函数，编译也无法通过。缺少了 PWT 的信息，编译器将无法定位正确的 < 实现，也就无法容许这样的代码。这也是泛型和协议紧密相连的原因。


## 泛型特化

相比于非泛型的代码，Swift 对泛型的处理模型添加了无法绕过的间接层代码，这显然会带来运行时的性能损耗。

幸运的是，在许多情况下 Swift 编译器可以使用一种叫做泛型特化 (generic specialization) 或者称作单态 (monomorphization) 的方式，来完全去除掉这个开销。 特化指的是编译器用 Int 这样的具体类型作为泛型参数类型，去把泛型类型或者函数 (比如 min< T >) 复制一份。然后，这个特化后的函数可以专门为 Int 进行优化，并去掉所有的间接层了。

泛型特化不仅仅节省了虚拟派发的开销，它也开启了更多优化的可能。比如内联 (inline)，如果没有特化的话，间接层将会是一个很大的障碍。

当你在编译代码时开启优化 (命令行中使用 swiftc -O 或者 SwiftPM 中使用 swift package build -c release) 时，优化器将会针对它所能看到的信息，为你的泛型类型和函数创建特化版本。

关于特化要记住的是，只有当优化器在编译调用侧时可以看到泛型类型或者函数的完整定义的情况下，特化才会发生。当调用者和被调用者在同一个文件时，这种情况是必然发生的。如果不是，那么你有两种选项来帮助优化器。

1. 打开“全模块优化” (whole module optimization)。在这个编译模式下，当前模块的所有文件都会在一起进行优化。除了泛型特化，全模块优化也会开启其他重要的优化策略。比如说，优化器会识别出那些在整个模块中没有子类的 internal class。因为 internal 修饰符确保了这个类不会被模块外看到，这也就意味着编译器可以把这个类的所有方法由动态派发替换成静态派发。”

2. 将泛型函数标记为 @inlinable 以便其他模块使用。这个标记会把函数体也作为模块接口的一部分进行导出，其他模块引用它时，优化器就也能看到这些代码。在这种情况下，当调用者进行编译时，虽然包含泛型函数的模块已经被编译过了，但是优化器仍然能生成一个该函数的特化版本并把它放到调用模块中。我们的 min 函数就拥有 @inlinable 标签：


