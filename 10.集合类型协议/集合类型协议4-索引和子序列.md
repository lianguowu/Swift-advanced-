# 集合类型协议4-索引和子序列


## 索引

索引表示了集合中的位置。每个集合都有两个特殊的索引值：startIndex 和 endIndex。startIndex 指定集合中第一个元素，endIndex 是集合中最后一个元素的下一个位置。所以 endIndex 并不是一个有效的下标索引，你可以用它创建索引的范围 `(someIndex..<endIndex)`，或者将它与别的索引进行比较，例如：控制循环的退出条件 `(while someIndex < endIndex)。`

到现在为止，我们都使用整数作为集合的索引（例如Array） 整数索引很直观，但它并不是唯一选项。集合类型的 Index 的唯一要求是，它必须实现 Comparable，换句话说，索引必须要有确定的顺序。

用 Dictionary 作为例子，因为我们使用字典的键来定位字典中的值，所以可能使用键来作为字典的索引看上去会是很自然的选择。但这是行不通的，因为你无法 (像计算整数索引位置一样) 移动一个键，你不能给出某个键之后的索引值应该是什么。另外，使用索引进行下标访问应该立即返回获取的元素，而不是再去搜索或者计算哈希值.

所以，字典的索引是 DictionaryIndex 类型，它是一个指向字典内部存储缓冲区的不透明值。事实上这个类型只是一个 Int 偏移值的封装.

而通过索引访问的方法是 Collection 协议所定义的，它总是返回非可选值。因为使用 (像是数组里的越界索引这样的) 无效的下标被认为是程序员犯的错误，即便程序“崩了”也是理所因当的事情：
```
protocol Collection {
	subscript(position: Index) -> Element { get }
}
```

注意，subscript 的返回类型是 Element。Element 类型是一个多元组：(key: Key, value: Value)，因此对 Dictionary，下标访问返回的是一个键值对，而非单个的 Value。这也是通过 for 循环遍历字典会得到键值对的原因.


## 索引失效

当集合发生改变时，索引可能会失效。失效有两层含义，它可能意味着虽然索引本身仍是有效的，但是它现在指向了一个另外的元素；或者有可能索引本身就已经无效了，通过它对集合访问将造成崩溃。

字典的索引不会随着新键值对的加入而失效，直到字典的尺寸增大到触发重新的内存分配。这是因为一般情况下字典存储的缓冲区内的元素位置是不会改变的，而在元素超过缓冲区尺寸时，缓冲区会被重新分配，其中的所有元素的哈希值也会被重新计算。从字典中移除元素总是会使索引失效。

索引应该是一个只存储包含描述元素位置所需最小信息的简单值。在尽可能的情况下，索引不应该持有对它们集合的引用。类似地，一个集合通常也无法区分它“自己的”索引和一个来自同样类型集合的索引。这对那些不透明的索引类型，例如：String.Index，也是适用的。

另外，在集合之间共享索引也是有其合理用法的，在切片上我们会大量使用这种方式。Collection 协议要求原集合的索引必须在切片上也命中同样的元素，这样一来，在切片之间共享索引就总是一个安全的操作。


## 索引步进

Swift 3 在集合处理索引遍历的方面引入了一个大的变化。现在，向前或者向后移动索引 (或者说，从一个给定索引计算出新的索引) 的任务是由集合来负责的了，而在 Swift 3 之前，索引是可以自行移动的。你之前可能会用 someIndex.successor() 来获取下一个索引，现在你需要写 collection.index(after: someIndex)

为什么 Swift 团队要做这样的变化？简单说，为了性能。通常，从一个索引获取到另一个索引会涉及到集合内部的信息。数组中的索引没有这个顾虑，因为在数组里索引的步进就是简单的加法运算。但是对于字符串索引，因为字符在 Swift 中是尺寸可变的，所以计算索引时就需要考虑字符的实际数据到底是什么。

在之前可以自行移动的索引模型中，索引必须保存一个对集合存储的引用。这个额外的引用会在集合被迭代修改时造成不必要的复制，它带来的开销足以抵消标准库中集合的写时复制特性带来的性能改善。

新的模型通过将索引保持为简单值，就可以解决这个问题。它的概念更容易理解，也让你可以更简单地实现自定义的索引类型。在大多数情况下，索引可以由一个或者两个高效地对集合底层存储元素位置进行编码的整数值所表示。新的索引模型的缺点是，它的语法会显得有一些啰嗦。


## 自定义集合索引

(详细代码见书)

作为非整数索引集合的例子，我们将会构建一种在字符串中迭代单词的方式。当你想要将一个字符串分割成一个个的单词，最简单的方法就是使用 split(separator:maxSplits:omittingEmptySubsequences:) (当然，这是对英文而言)，这个方法将使用提供的分割元素进行分割，把一个集合转变为其 SubSequence 的数组
```
var str = "Still I see monsters"
str.split(separator: " ") // ["Still", "I", "see", "monsters"]
```
返回数组中的每个单词的类型都是 SubString，这正是 String 所关联的 SubSequence 类型。当你想要分割一个集合类型时，split 方法往往是最适合的工具。不过，它有一个缺点：这个方法将会热心地为你计算出整个数组。如果你的字符串非常大，而且你只需要前几个词的话，这么做是相当低效的。为了提高性能，我们要构建一个 Words 集合，它能够让我们不一次性地计算出所有单词，而是可以用延迟加载的方式进行迭代.

我们完全可以将 String 替换成任意集合类型。比如，我们可以用同样的算法来将 Data 延迟分割为可处理的小数据块。再强调一次，Swift Algorithms 包已经在 split 的延迟重载中将这些都做好了。


## 子序列

Collection 协议还有一个关联类型，叫做 SubSequence。它表示集合中一个连续的子区间：
```
extension Collection {
	associatedtype SubSequence: Collection = Slice<Self>
		where Element == SubSequence.Element,
			SubSequence == SubSequence.SubSequence
}
```

SubSequence用于那些返回原始集合类型切片的操作：

* prefix 和 suffix — 获取开头或结尾的 n 个元素。
* prefix(while:) - 从集合开始，获取满足 while 指定条件的操作。
* dropFirst 和 dropLast — 返回移除掉前 n 个或后 n 个元素的子序列。
* drop(while:) - 移除元素，直到条件不再为真，然后返回剩余元素。
* split — 将一个序列通过指定的分隔元素截断，返回子序列的数组。

另外，基于范围的下标操作符也会以切片的形式返回这个范围内的索引在原始集合中标记的区间。这样做，相比于直接返回一个包含所有子序列元素的新集合 (例如数组) 的好处就是不会招致额外的内存分配，因为子序列和它们原始的集合类型是共享内部存储的。

默认情况下，Collection 会把 `Slice<Self>` 作为自己的 SubSequence 类型。但很多具体类型都有它们自己定制的实现：例如，String 的 SubSequence 类型是 Substring，Array 的 SubSequence 类型是 ArraySlice。

在有些时候，让子序列和原始集合的类型一致，也就是 SubSequence == Self，会非常方便。因为这样，只要能传递原始集合类型的地方，你也都能够使用切片类型。Foundation 中的 Data 就是这么做的，所以当你见到一个 Data 实例的时候，你无法分辨这究竟是一块儿完整的数据 (startIndex == 0 并且 endIndex == count)，还是一大块数据的切片 (拥有不是基于0开始的索引)。

但标准库中的集合却拥有不一样的切片类型，这么做的主要考量是为了防止不经意的内存“泄漏”，一个非常小的切片将会持有它原来的集合类型 (有可能非常大)。在切片的生命周期比预期要长得多的时候，这可能造成一些问题。使用它们自己的类型来表示切片，可以比较容易将它们的生命周期绑定到局部作用域中。

鉴于它们的内存开销很低，子序列非常适合表达中间结果。但是，为了避免小块切片意外地把整个原始序列保持在内存里，通常不建议长时间保存子序列 (例如：定义一个子序列属性)，或者把它传递给有可能造成这种结果的方法。为了切断子序列和原始集合类型之间的关系，我们可以用子序列创建一个新集合，例如：String(substring) 或 Array(arraySlice)。


## 切片

所有的集合类型都有切片操作的默认实现，并有一个接受 `Range<Index>` 作为参数的 subscript 方法。下面的操作等价于 words.dropFirst():
```
let words: Words = Words("one two three")
let onePastStart = words.index(after: words.startIndex)
let firstDropped = words[onePastStart..<words.endIndex]
Array(firstDropped) // ["two", "three"]”
```

默认情况下，firstDropped 的类型不是 Words，而是 `Slice<Words>。`“Slice 非常适合作为默认的子序列类型，不过当你创建一个自定义集合类型时，最好还是考虑下是否能将集合类型本身当作它的 SubSequence 使用。

将集合类型的 SubSequence 定义为和集合类型相同的类型，可以减轻集合类型使用者的负担，因为他们只需要理解单个类型就可以了，而不需要学习两个类型。不过另一面，让原始集合和它的切片使用不同的类型，有助于避免意外的内存“泄漏”，这也是标准库中使用 ArraySlice 和 Substring 来作为 Array 和 String 的子序列的原因。


## 切片与原集合共享索引

Collection 协议还有另一个正式的要求，那就是切片的索引可以和原集合的索引互换使用。Swift 文档是这样陈述这个要求的：

集合类型和它的切片拥有相同的索引。只要集合和它的切片在切片被创建后没有改变，切片中某个索引位置上的元素，应当也存在于原集合中同样的索引位置上。

这种模型带来了一个很重要的暗示，那就是即使在使用整数索引时，一个集合的索引也并不需要从 0 开始。

而我们之前提到过的 Data 在集合的这个特性下，用起来就比较危险了。Data 用整数作为索引，所以很自然的就会想到用数字 0 表示 Data 的起始位置。然而事实并非总是如此，因为 Data 的 SubSequence 类型也是它自己”

如果你确实需要访问索引，使用 for index in collection.indices 在绝大多数时候都比手工计算更可靠。但这也有一个例外，如果你通过索引进行迭代的同时修改了集合，indices 持有的原始集合的强引用会破坏写时复制的优化机制，并引发本不需要的额外拷贝。取决于集合自身的大小，这个拷贝可能会带来非常严重的性能影响 (并不是所有集合使用的 Indices 类型都会持有原始集合的强引用，但由于标准库中默认的 DefaultIndices 就是这样做的，所以绝大多数集合类型都有这样的性质)。

要避免这件事情发生，你可以将 for 循环替换为 while 循环，然后手动在每次迭代的时候增加索引值，这样你就不会用到 indices 属性。当你这么做的时候，一定要记住要从 collection.startIndex 开始进行循环，而不要把 0 作为开始。
