# 协议4-存在体

## 存在体

严格来说，在 Swift 中是不能把协议当作一个具体类型来使用的，它们只能用来约束泛型参数。不过，下面的代码还是可以通过编译的 (我们使用了上面例子中的 DrawingContext 协议)：
`let context: DrawingContext = SVG()`

当我们把协议当作具体类型使用的时候，编译器会在背后为协议创建一个包装类型，叫做存在体 (existential)。

但是存在提语法并不直观，为此，Swift 5.6 为存在体引入了新的 any P 语法。旧的使用方式现在依然有效，但是它会在未来的语言版本中被弃用或者移除。

`let context: any DrawingContext = SVG()`

我们可以把 any DrawingContext 看作是类似 Any< DrawingContext > 的另一种写法 (假若 Any 是一个泛型类型的话)，也就是一个带有额外约束的 Any 值。当编译器看到 any DrawingContext 时，它会创建一个 (四个字长，也就是 64 位系统中的 32 字节的) Any 盒子，并在其中为类型实现的每个协议添加一个 8 字节的协议目击者。

这个为协议类型的值创建的盒子，也被叫做存在体容器 (existential container)。这是编译器必须要做的事情，因为它需要在编译期确认类型的大小。不同的尺寸的各种类型都有可能满足某个协议，因此将协议包装到一个存在体容器中，就可以创建一个固定尺寸的类型，这样编译器就可以在内存中确定它的布局了。Any 容器的四个字中的三个，会用来直接内联存放一些小的值。如果被包装的值大于三个字长，那么编译器就会把它放到堆上，并在盒子里存储一个指针。第四个字会被用来存放一个指针，它指向被包装类型的类型元数据记录。这个类型元数据包含了值目击表，一些诸如创建、销毁或者复制值的基本的操作，就被包括在这个表内。


## 存在体和关联类型

在 Swift 5.6 中，存在体的使用被限制在那些既没有关联类型又不针对 Self 进行要求 (除了 Self 被用在返回类型的情况以外) 的协议里。在 Swift 5.7 中，这个限制会被去掉，并且任意协议都可以被当作存在体使用了。但还是有一些基本的限制

例如
```
let a: any Equatable = "Alice" // Error in Swift 5.5, legal in Swift 5.7
let b: any Equatable = "Bob"
a == b 
// Swift 5.7 error: binary operator '==' cannot be applied
// to two 'Equatable' operands.

//上面的代码在 Swift 5.7 中也不能编译，因为 == 操作符在它的参数中引用的是 Self：
public protocol Equatable {
	static func == (lhs: Self, rhs: Self) -> Bool
}
```
== 函数会期望两个参数拥有完全一样的类型。但存在体无法满足这个要求，因为它们会把类型信息抹消掉，这样编译器就不再知道 a 和 b 其实是同样类型这一事实了。

我们所看到的对于 Self 的规则，也同样适用于那些引用了关联类型的协议要求方法。在参数中使用了关联类型的函数，同样不能被用于存在体上”

但是当 Self 和关联类型被用作返回类型是时，编译器知道可以把结果再次打包到另一个存在体容器中。表达式 number.nextUp 的静态类型是 any FloatingPoint，或者Optional< Any >。


## 存在体无法遵守协议

一个存在体类型不能遵守和“它的”名字相同的那个协议。换句话说，你不能把一个存在体 any P 传递给 func f< T: P >(_ x: P) 这样的泛型函数。

这一限制的基本原因和前一节中的相同：并非所有的协议方法都在存在体中可用。除了对 Self 或者关联类型有引用的协议要求方法以外，这一规则也对初始化方法和静态方法适用，因为这些方法可以被看作是接受 Self 作为第一个参数的一类特殊函数。

```
extension JSONDecoder {
	func decode<T: Decodable>(_ type: T.Type, from data: Data) throws -> T
}
```
decode 方法最终会调用 T.init(from:)，它是 Decodable 协议中对于初始化方法的所要求的部分。如果我们允许把存在体类型 (any Decodable).self 传递给 decode，编译器就不知道要初始化什么类型了。

Error 存在体确实是遵守 Error 协议的。这个特例是写死在编译器里的，它允许 any Error (作为存在体) 可以用作泛型参数的类型，来让泛型参数满足 Error (作为协议) 的约束。如果没有这一特性，那么一些很常见的类型，比如 Result< Int, any Error > (在 Swift 5.6 之前被写作 Result< Int, Error >) 将会导致错误。假如这样，你就必须要指定一个具体的错误类型，比如 Result< Int, URLError >，才能进行编译了。这个编译器魔法之所以能够生效，是因为 Error 协议是一个纯粹的标记协议 (marker protocol)，它没有任何要求，所以不会有无法满足协议要求的问题。


## 不要过早的使用存在体

一般来说，除非你需要变量装箱所带来的灵活性 (比如在一个集合类型中存储类型相异的值)，否则都应该尽量选择使用泛型。存在体会抹去类型信息，而泛型则会保留它。频繁地把值装箱到存在体容器中，再频繁地把它从容器中取出，本身就对性能不利；此外，过早地抹去类型将不可避免地阻止一些编译器优化。
