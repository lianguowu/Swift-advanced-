# 协议4-不透明类型


## 不透明类型

不透明类型是 API 作者用来在不借助存在体 (它会抹消掉类型信息) 的前提下把具体返回类型隐藏起来的一种手段。不透明类型对应的语法是 some MyProtocol，它代表“ 某个满足了所列举出的约束的具体类型 ”的意思。对于用户来说，底层的具体类型被隐藏了，用户只能通过协议所声明的能力 (这里是 MyProtocol) 来操作这个值。到这里为止听起来和存在体很相似，但是和存在体不同的是，类型系统会保留不透明类型 (所隐藏) 的类型信息。这允许用户在使用不透明类型时能做到一些在存在体上无法做到的事情，比如说使用带有 Self 或者关联类型约束的 API。另外，some MyProtocol 这个不透明类型是满足了协议的，而我们已经看到过，存在体是不满足协议的。相比于存在体，不透明类型总体来说更利于编译器进行优化。

Apple 在 SwiftUI 中大量使用了不透明类型。不透明类型在信息隐藏方面有两个作用：
1. 让深层嵌套的泛型更容易使用，
2. 将实现细节隐藏起来。

设计的嵌套结构类型text 值的类型是 `Concat<Concat<Bold<String>, String>, Italic<String>>`。这揭示了深度嵌套的泛型类型的两个常见问题。

1. 嵌套的泛型很快会变得无法维护。类型推断在一定程度上可以帮助解决这个问题，但是函数声明却需要明确的返回类型。
2. 类型暴露了实现细节。一但你把一个类型签名当作公开 API 发布，你想要再进行修改，就会破坏客户端的实现。

不透明类型通过让我们把一个像 `Concat<Self, Other>`的具体类型，替换成 some RichText 来解决这些问题。

```
extension RichText {
	func bold() -> some RichText {
		Bold(text: self)
	}
	func italic() -> some RichText {
		Italic(text: self)
	}
	func appending<Other: RichText>(_ other: Other) -> some RichText {
		Concat(a: self, b: other)
	}
}
```

不同之处在于，text 的具体类型现在被隐藏了，就好像 API 返回的是一个存在体一样。新的函数签名更好地反映出我们作为 RichText 库的作者，对所提供的内容向用户所做出的约定。因为调用者现在只能访问不透明类型所指定的能力 (这里是 RichText)，用户也不需要知道内部类型的细节了。就算底层的具体类型发生了变化，也没有人需要去更新他们的代码了。


## 不透明类型的规则

不透明类型的正式的规则概述如下：

1. 不透明类型可以出现在函数的返回类型，属性/变量，或者下标中。因为它们是专门关于输出类型的，所以它们也被叫做不透明的结果类型。（swift5.7中将some P语法拓展到函数参数中去）

2. 通常来说约束是某个协议，但它也可以是一个类 (如 some UIView 表示任意 UIView 的子类) 或者所个约束的组合 (some AnyObject & Encodable)。

3. 不透明类型的函数必须在所有代码路径返回相同的类型。

4. 不透明类型的函数必须在每次调用时都返回相同的具体类型。编译器“知晓”而且它也会利用这一点。

5. 你可以通过动态转换还原出具体类型。不透明类型只被静态类型系统所知，在运行时它们不做任何表达。


## 类型消除器 （看不懂后期...再看）

尽管我们无法为带有 Self 或关联类型约束的协议创建存在体，但我们可以编写一个执行类似功能的函数，叫做：类型消除器 （手动编写）。


