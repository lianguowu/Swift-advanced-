# 泛型1-泛型类型和Any

## 泛型

泛型编程是一种可以保持类型安全性的代码重用技术。类似的，为了以类型安全的方式提供访问和修改数组的API，Array也是一个泛型类型。

当谈论 Swift 中的泛型编程时，我们通常指的是对类型泛化后的编程 (一个显著的语法特征就是要使用尖括号具像化这些泛化的类型，例如：Array< Int >)。不过，泛型这个概念却远不止泛化类型。我们可以认为泛型是多态 (polymoyphism) 的一种形式，而多态则是指一个接口或名称可以通过多个类型进行访问的现象。

至少有四种不同的概念，可以归纳到多态编程这个范畴里

1. 我们可以定义多个同名但是类型不同的函数。例如，在函数这一章，我们定义了三个不同的 sortDescriptor 方法，它们每个都有不同的参数类型。这种用法叫做重载 (overloading)，或者更技术地说，这是一种 (为了解决排序这个问题而特别设置的) 专属多态 (ad hod polymorphism)。

2. 当一个函数或方法接受类 C 作为参数的时候，我们也可以给它传递 C 的派生类，这种用法叫做子类型多态 (subtype polymorphism)。

3. 当一个函数 (通过尖括号语法) 接受泛型参数的时候，我们管这个函数叫做泛型函数 (generic function) (这和泛型类型类似)。这种用法叫做参数化多态 (parametric polymorphism)。这些泛型化的参数，也被叫做泛型 (generics)。

4. 我们可以定义一个协议并让多个类型实现它。这是另外一种更加结构化的专属多态。


## 泛型类型

函数和方法并不是唯一的泛型类型。我们还可以有泛型结构体，泛型类和泛型枚举。

```
enum Optional<Wrapped> {
	case none
	case some(Wrapped)
}
```
当我们去浏览 Swift 标准库的时候，就会看到其中包含了很多具体类型，但也有很多泛型类型 (例如：Array，Dictionary 和 Result)。Array 有一个泛型参数 Element，这就让我们可以使用任何一个具体类型来创建数组。
```
//自定义泛型枚举
enum BinaryTree<Element> {
	case leaf
	indirect case node(Element, l: BinaryTree<Element>, r: BinaryTree<Element>)
}
```

当我们把泛型类型转换成具体类型的时候，一个泛型参数只能对应一个具体类型。


## 扩展泛型类型

在 BinaryTree 的作用域里，泛型参数 Element 都是可用的。例如，当为 BinaryTree 编写扩展的时候，也可以像使用一个具体类型一样来使用 Element。

在 Swift 里，很多集合类型都是泛型类型 (例如：Array，Set 和 Dictionary)。但是，泛型这项技术本身可不仅仅用在表达集合类型上。它的应用几乎贯穿了整个 Swift 标准库的实现，例如：

1. Optional 用泛型参数抽象它包装的类型。
2. Result 有两个泛型参数：分别表示成功和失败这两种结果对应的值的类型。
3. Unsafe[Mutable]Pointer 用泛型参数表示指针指向的内存的类型。
4. Key paths 中使用了泛型表示它们的根类型以及路径的值类型。
5. 各种表示范围的类型，使用了泛型表达它们的元素类型 (Bound)。


## 泛型和Any

泛型和 Any 可以被看作类似的用途，但它们有截然不同的表现。在没有泛型的编程语言里，Any 通常用来实现和泛型同样的效果，但是却缺少了类型安全性。这通常意味着要使用一些运行时特性，例如内省 (introspection) 或动态类型转换，把 Any 这种不确定的类型变成一个确定的具体类型。而泛型不仅能解决绝大部分同样的问题，还能带来编译期类型检查以及提高运行时性能等额外的好处。

在我们的经验里，泛型类型对于源码阅读有很大帮助。更确切地说，只要看到形如 reduce 或 map 这样的函数或方法，我们不用去猜它们的功能，单就签名中的泛型类型，就已经约束了可能的实现方法。


